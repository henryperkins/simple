import asyncio
from typing import Optional, Dict, Any
from core.logger import LoggerSetup
from core.types import DocumentationContext, DocstringData
from ai_interaction import AIInteractionHandler
from core.response_parsing import ResponseParsingService
from core.docstring_processor import DocstringProcessor
from core.markdown_generator import MarkdownGenerator
from exceptions import DocumentationError

logger = LoggerSetup.get_logger(__name__)

class DocStringManager:
    """Manages the generation of documentation, integrating AI-generated content."""

    def __init__(
        self,
        context: DocumentationContext,
        ai_handler: AIInteractionHandler,
        response_parser: ResponseParsingService
    ):
        """
        Initialize the DocStringManager.

        Args:
            context (DocumentationContext): The context containing source code and metadata.
            ai_handler (AIInteractionHandler): Handler for AI interactions.
            response_parser (ResponseParsingService): Service for parsing AI responses.
        """
        self.context = context
        self.ai_handler = ai_handler
        self.response_parser = response_parser
        self.docstring_processor = DocstringProcessor()

    async def generate_documentation(self) -> str:
        """
        Generate documentation for the given source code.

        Returns:
            str: The generated markdown documentation.

        Raises:
            DocumentationError: If documentation generation fails.
        """
        try:
            # If AI-generated documentation is not available, process the code
            if not self.context.ai_generated:
                try:
                    # Generate cache key based on file content
                    cache_key = f"doc:{self.context.module_path.stem}:{hash(self.context.source_code.encode())}"
                    
                    # Process code with AI handler
                    result = await self.ai_handler.process_code(
                        source_code=self.context.source_code,
                        cache_key=cache_key
                    )

                    if not result:
                        raise DocumentationError("AI processing failed")

                    updated_code, ai_docs = result

                    # Update the context with AI-generated documentation
                    self.context.source_code = updated_code
                    self.context.ai_generated = ai_docs

                except Exception as e:
                    logger.error(f"Error processing code for AI documentation: {e}")
                    # If AI processing fails, use a fallback message
                    self.context.ai_generated = {
                        'summary': "AI-generated documentation not available",
                        'description': "Documentation could not be generated by AI service",
                        'args': [],
                        'returns': {'type': 'Any', 'description': ''},
                        'raises': []
                    }

            # Use MarkdownGenerator to generate the markdown documentation
            markdown_generator = MarkdownGenerator()
            documentation = markdown_generator.generate(self.context.__dict__)
            return documentation

        except Exception as e:
            logger.error(f"Error generating documentation: {e}")
            raise DocumentationError(f"Failed to generate documentation: {e}")

    async def update_docstring(self, existing: str, new_content: str) -> str:
        """
        Update an existing docstring with new content.

        Args:
            existing (str): The existing docstring.
            new_content (str): The new content to merge.

        Returns:
            str: The updated docstring.
        """
        try:
            # Parse both docstrings
            existing_data = self.docstring_processor.parse(existing)
            new_data = self.docstring_processor.parse(new_content)

            # Merge data, preferring new content but keeping existing if new is empty
            merged = DocstringData(
                summary=new_data.summary or existing_data.summary,
                description=new_data.description or existing_data.description,
                args=new_data.args or existing_data.args,
                returns=new_data.returns or existing_data.returns,
                raises=new_data.raises or existing_data.raises,
                complexity=new_data.complexity or existing_data.complexity
            )

            return self.docstring_processor.format(merged)

        except Exception as e:
            logger.error(f"Error updating docstring: {e}")
            raise DocumentationError(f"Failed to update docstring: {e}")

    async def __aenter__(self) -> 'DocStringManager':
        """Async context manager entry."""
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit."""
        pass  # Cleanup if needed